import {BigIntModule} from './BigIntModule.mjs.js';
import {Barrett} from './Barrett.mjs.js';

// RSA, a suite of routines for performing RSA public-key computations in JavaScript.
//
// Requires BigInt.js and Barrett.js.
//
// Copyright 1998-2005 David Shapiro.
//
// You may use, re-use, abuse, copy, and modify this code to your liking, but
// please keep this header.
// Thanks!
// 
// Dave Shapiro
// dave@ohdave.com 

export var RSA = {
  initialise: function initialise(maxDigits) {
    BigIntModule.reset();
    BigIntModule.init(maxDigits);
  } ,
  
  log: function log(txt) {
    console.log('premium.rsa', txt);
  },
  
  
/*
 * @encryptionExponent  The encryption exponent (i.e. public encryption key) to be used for
 *                      encrypting messages.  If you aren't doing any encrypting, a dummy
 *                      exponent such as "10001" can be passed.
 * @decryptionExponent  The decryption exponent (i.e. private decryption key) to be used for
 *                      decrypting messages.  If you aren't doing any decrypting, a dummy
 *                      exponent such as "10001" can be passed.
 * @modulus             The modulus to be used both for encrypting and decrypting messages.
 * @keylength           The optional length of the key, in bits.  If omitted, RSAKeyPair will
 *                      attempt to derive a key length 
 * returns              The "new" object creator returns an
 *                      instance of a key object that can be
 *                      used to encrypt/decrypt messages.
 */
  RSAKeyPair: function RSAKeyPair(encryptionExponent, decryptionExponent, modulus, keylength = 0) {
    BigIntModule.init();
    this.e = BigIntModule.biFromHex(encryptionExponent);
    this.d = BigIntModule.biFromHex(decryptionExponent);
    this.m = BigIntModule.biFromHex(modulus);
    // We can do two bytes per digit, so
    // chunkSize = 2 * (number of digits in modulus - 1).
    // Since biHighIndex returns the high index, not the number of digits, 1 has
    // already been subtracted.
    if (!keylength) {
      this.chunkSize = 2 * BigIntModule.biHighIndex(this.m);
    } else {
      this.chunkSize = keylength / 8;
    }
    this.radix = 16;
    this.barrett = new Barrett(this.m);
  },
  
/** 
  * @key  The previously-built RSA key whose public key component is to be used to
  *       encrypt the plaintext string.
  * @s    The plaintext string that is to be encrypted, using the RSA assymmetric
  *       encryption method.
  * @pad  when extending the plaintext to the full chunk size required by the RSA
  *       algorithm.  To maintain compatibility with other crypto libraries, the
  *       padding method is described by a string.  The default, if not
  *       specified is "OHDave".  Here are the choices:
  *       'OHDave' - original padding method employed by Dave Shapiro and Rob Saunders.  
  *                  If this method is chosen, the plaintext can be of any length.
  *       'NoPadding' - truncates the plaintext to the length of the RSA key, if it is longer.  If
  *                     its length is shorter, it is padded with zeros.  In either case, the plaintext 
  *                     string is reversed to preserve big-endian order before it is encrypted to
  *                     maintain compatibility with real crypto libraries such as OpenSSL or Microsoft.
  *       'PKCS1Padding' - the PKCS1v1.5 padding method (as described in RFC 2313) is employed to pad the
  *                        plaintext string.  The plaintext string must be no longer than the
  *                        length of the RSA key minus 11, since PKCS1v1.5 requires 3 bytes of overhead 
  *                        and specifies a minimum pad of 8 bytes.  The plaintext string is padded with
  *                        randomly-generated bytes and then its order is reversed to preserve big-endian 
  *                        order before it is encrypted to maintain compatibility with real crypto
  *                        libraries such as OpenSSL or Microsoft.  When the cyphertext is to be decrypted 
  *                        by a crypto library, the library routine's "PKCS1Padding" flag, or its
  *                        equivalent, should be used.  
  * returns   The cyphertext block that results from encrypting the plaintext string s
  *           with the RSA key.
  */    
  encryptedString: function encryptedString(key, s, pad ) {
    const PAD_OHDave = 0;
    const PAD_NoPadding = 1;
    const PAD_PKCS1 = 2;
    if (!pad) pad = 'OHDave';
    if (!key) throw('RSA.encryptedString: No valid encryption key!');
    if (!s) throw('RSA.encryptedString: Nothing to encrypt!');
    let padtype;
    switch (pad) {
      case 'OHDave':
        padtype = PAD_OHDave;
        break;
      case 'NoPadding':
        padtype = PAD_NoPadding;
        break;
      case 'PKCS1Padding':
        padtype = PAD_PKCS1;
        break;
      default:
        throw('Invalid padding parameter: ' + pad);
    } 
    BigIntModule.init();
    
    /* If we're not using Dave's padding method, we need to truncate long
     * plaintext blocks to the correct length for the padding method used:
     *       NoPadding    - key length
     *       PKCS1Padding - key length - 11
     */
    let sl, j; 
    switch(padtype) {
      case PAD_OHDave:
        sl = s.length;  // j is unused at first
        break;
      case PAD_NoPadding:
        if (sl > key.chunkSize) {
          sl = key.chunkSize;
        }
        j = key.chunkSize - 1;
        break;
      case PAD_PKCS1:
        if (sl > (key.chunkSize - 11)) {
          sl = key.chunkSize - 11;
        }
        j = sl - 1;
        break;
    }
    
    /*
     * Convert the plaintext string to an array of characters so that we can work
     * with individual characters.
     *
     * Note that, if we're talking to a real crypto library at the other end, we
     * reverse the plaintext order to preserve big-endian order.
     */
    let a = new Array(),
        i = 0;
    for (i = 0; i < sl; i++, j--) {
      if  (padtype == PAD_OHDave)
        a.push(s.charCodeAt(i));  // a[i]=
      else
        a[j] = s.charCodeAt(i); // reverse order
    }

    // add the padding
    // Altered by Rob Saunders (rob@robsaunders.net). New routine pads the
    // string after it has been converted to an array. This fixes an
    // incompatibility with Flash MX's ActionScript.
    if (padtype == PAD_NoPadding)
      i = 0;

    j = key.chunkSize - (sl % key.chunkSize);
    while (j > 0) {
      let rpad = (padtype == PAD_PKCS1) ? 
                 Math.floor(Math.random() * 255)+1 :  // avoid 0
                 0;
      a[i++] = rpad;
      j--;
    }
    
    /*
    * For PKCS1v1.5 padding, we need to fill in the block header.
    */
    if (padtype == PAD_PKCS1) {
      a[sl] = 0;
      a[key.chunkSize - 2] = 2;
      a[key.chunkSize - 1] = 0;
    }

    let al = a.length,
        result = "",
        k, block;
    for (i = 0; i < al; i += key.chunkSize) {
      block = new BigIntModule.BigInt();
      j = 0;
      for (k = i; k < (i + key.chunkSize); ++j) {
        block.digits[j] = a[k++];
        block.digits[j] += a[k++] << 8;
      }
      let crypt = key.barrett.powMod(block, key.e),
          text = (key.radix == 16) ? BigIntModule.biToHex(crypt) : BigIntModule.biToString(crypt, key.radix);
      result += (text + " ");
    }
    return result.substring(0, result.length - 1); // Remove last space.
  },

/** 
  * @key  The previously-built RSA key whose private key component is to be used to
  *       decrypt the cyphertext string.
  * @c    The cyphertext string that is to be decrypted, using the RSA assymmetric
  *       decryption method.
  * returns The plaintext block that results from decrypting the cyphertext string c
  *         with the RSA key.
  * Only the OHDave padding method (e.g. zeros) is supported by
  * this routine *AND* this routine expects little-endian cyphertext, as
  * created by the encryptedString routine (in this module) or the RSAEncode
  * routine (in either CryptoFuncs.pm or CryptoFuncs.php).
  */
  decryptedString: function decryptedString(key, c) {
    if (!key) throw('RSA.decryptedString: No valid decryption key!');
    if (!c) throw('RSA.decryptedString: Nothing to decrypt!');
    BigIntModule.init();
    let blocks = c.split(" "),
        result = "",
        i, j, b;
    for (i = 0; i < blocks.length; ++i) {
      let bi;
      if (key.radix == 16) {
        bi = BigIntModule.biFromHex(blocks[i]);
      }
      else {
        bi = BigIntModule.biFromString(blocks[i], key.radix);
      }
      b = key.barrett.powMod(bi, key.d);
      for (j = 0; j <= BigIntModule.biHighIndex(b); ++j) {
        result += String.fromCharCode(b.digits[j] & 255,
                                      b.digits[j] >> 8);
      }
    }
    // Remove trailing null, if any.
    if (result.charCodeAt(result.length - 1) == 0) {
      result = result.substring(0, result.length - 1);
    }
    return result;
  }

}